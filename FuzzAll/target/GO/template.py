go_std = {
    "docstring": """
archive
tar
Package tar implements access to tar archives.
zip
Package zip provides support for reading and writing ZIP archives.
bufio
Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.
builtin
Package builtin provides documentation for Go's predeclared identifiers.
bytes
Package bytes implements functions for the manipulation of byte slices.
compress
bzip2
Package bzip2 implements bzip2 decompression.
flate
Package flate implements the DEFLATE compressed data format, described in RFC 1951.
gzip
Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.
lzw
Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19.
zlib
Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.
container
heap
Package heap provides heap operations for any type that implements heap.Interface.
list
Package list implements a doubly linked list.
ring
Package ring implements operations on circular lists.
context
Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.
crypto
Package crypto collects common cryptographic constants.
aes
Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.
cipher
Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations.
des
Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.
dsa
Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.
ecdh
Package ecdh implements Elliptic Curve Diffie-Hellman over NIST curves and Curve25519.
ecdsa
Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-4 and SEC 1, Version 2.0.
ed25519
Package ed25519 implements the Ed25519 signature algorithm.
elliptic
Package elliptic implements the standard NIST P-224, P-256, P-384, and P-521 elliptic curves over prime fields.
hmac
Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198.
md5
Package md5 implements the MD5 hash algorithm as defined in RFC 1321.
rand
Package rand implements a cryptographically secure random number generator.
rc4
Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography.
rsa
Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.
sha1
Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.
sha256
Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4.
sha512
Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.
subtle
Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.
tls
Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446.
x509
Package x509 implements a subset of the X.509 standard.
x509/pkix
Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.
database
sql
Package sql provides a generic interface around SQL (or SQL-like) databases.
sql/driver
Package driver defines interfaces to be implemented by database drivers as used by package sql.
debug
buildinfo
Package buildinfo provides access to information embedded in a Go binary about how it was built.
dwarf
Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at http://dwarfstd.org/doc/dwarf-2.0.0.pdf.
elf
Package elf implements access to ELF object files.
gosym
Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers.
macho
Package macho implements access to Mach-O object files.
pe
Package pe implements access to PE (Microsoft Windows Portable Executable) files.
plan9obj
Package plan9obj implements access to Plan 9 a.out object files.
embed
Package embed provides access to files embedded in the running Go program.
encoding
Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations.
ascii85
Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.
asn1
Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.
base32
Package base32 implements base32 encoding as specified by RFC 4648.
base64
Package base64 implements base64 encoding as specified by RFC 4648.
binary
Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.
csv
Package csv reads and writes comma-separated values (CSV) files.
gob
Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver).
hex
Package hex implements hexadecimal encoding and decoding.
json
Package json implements encoding and decoding of JSON as defined in RFC 7159.
pem
Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail.
xml
Package xml implements a simple XML 1.0 parser that understands XML name spaces.
errors
Package errors implements functions to manipulate errors.
expvar
Package expvar provides a standardized interface to public variables, such as operation counters in servers.
flag
Package flag implements command-line flag parsing.
fmt
Package fmt implements formatted I/O with functions analogous to C's printf and scanf.
go
ast
Package ast declares the types used to represent syntax trees for Go packages.
build
Package build gathers information about Go packages.
build/constraint
Package constraint implements parsing and evaluation of build constraint lines.
constant
Package constant implements Values representing untyped Go constants and their corresponding operations.
doc
Package doc extracts source code documentation from a Go AST.
doc/comment
Package comment implements parsing and reformatting of Go doc comments, (documentation comments), which are comments that immediately precede a top-level declaration of a package, const, func, type, or var.
format
Package format implements standard formatting of Go source.
importer
Package importer provides access to export data importers.
parser
Package parser implements a parser for Go source files.
printer
Package printer implements printing of AST nodes.
scanner
Package scanner implements a scanner for Go source text.
token
Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates).
types
Package types declares the data types and implements the algorithms for type-checking of Go packages.
hash
Package hash provides interfaces for hash functions.
adler32
Package adler32 implements the Adler-32 checksum.
crc32
Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum.
crc64
Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum.
fnv
Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo.
maphash
Package maphash provides hash functions on byte sequences.
html
Package html provides functions for escaping and unescaping HTML text.
template
Package template (html/template) implements data-driven templates for generating HTML output safe against code injection.
image
Package image implements a basic 2-D image library.
color
Package color implements a basic color library.
color/palette
Package palette provides standard color palettes.
draw
Package draw provides image composition functions.
gif
Package gif implements a GIF image decoder and encoder.
jpeg
Package jpeg implements a JPEG image decoder and encoder.
png
Package png implements a PNG image decoder and encoder.
index
suffixarray
Package suffixarray implements substring search in logarithmic time using an in-memory suffix array.
io
Package io provides basic interfaces to I/O primitives.
fs
Package fs defines basic interfaces to a file system.
ioutil
Package ioutil implements some I/O utility functions.
log
Package log implements a simple logging package.
syslog
Package syslog provides a simple interface to the system log service.
math
Package math provides basic constants and mathematical functions.
big
Package big implements arbitrary-precision arithmetic (big numbers).
bits
Package bits implements bit counting and manipulation functions for the predeclared unsigned integer types.
cmplx
Package cmplx provides basic constants and mathematical functions for complex numbers.
rand
Package rand implements pseudo-random number generators unsuitable for security-sensitive work.
mime
Package mime implements parts of the MIME spec.
multipart
Package multipart implements MIME multipart parsing, as defined in RFC 2046.
quotedprintable
Package quotedprintable implements quoted-printable encoding as specified by RFC 2045.
net
Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.
http
Package http provides HTTP client and server implementations.
http/cgi
Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.
http/cookiejar
Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.
http/fcgi
Package fcgi implements the FastCGI protocol.
http/httptest
Package httptest provides utilities for HTTP testing.
http/httptrace
Package httptrace provides mechanisms to trace the events within HTTP client requests.
http/httputil
Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.
http/pprof
Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.
mail
Package mail implements parsing of mail messages.
netip
Package netip defines an IP address type that's a small value type.
rpc
Package rpc provides access to the exported methods of an object across a network or other I/O connection.
rpc/jsonrpc
Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package.
smtp
Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.
textproto
Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.
url
Package url parses URLs and implements query escaping.
os
Package os provides a platform-independent interface to operating system functionality.
exec
Package exec runs external commands.
signal
Package signal implements access to incoming signals.
user
Package user allows user account lookups by name or id.
path
Package path implements utility routines for manipulating slash-separated paths.
filepath
Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.
plugin
Package plugin implements loading and symbol resolution of Go plugins.
reflect
Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types.
regexp
Package regexp implements regular expression search.
syntax
Package syntax parses regular expressions into parse trees and compiles parse trees into programs.
runtime
Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines.
cgo
Package cgo contains runtime support for code generated by the cgo tool.
coverage
debug
Package debug contains facilities for programs to debug themselves while they are running.
metrics
Package metrics provides a stable interface to access implementation-defined metrics exported by the Go runtime.
pprof
Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.
race
Package race implements data race detection logic.
trace
Package trace contains facilities for programs to generate traces for the Go execution tracer.
sort
Package sort provides primitives for sorting slices and user-defined collections.
strconv
Package strconv implements conversions to and from string representations of basic data types.
strings
Package strings implements simple functions to manipulate UTF-8 encoded strings.
sync
Package sync provides basic synchronization primitives such as mutual exclusion locks.
atomic
Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.
syscall
Package syscall contains an interface to the low-level operating system primitives.
js
Package js gives access to the WebAssembly host environment when using the js/wasm architecture.
testing
Package testing provides support for automated testing of Go packages.
fstest
Package fstest implements support for testing implementations and users of file systems.
iotest
Package iotest implements Readers and Writers useful mainly for testing.
quick
Package quick implements utility functions to help with black box testing.
text
scanner
Package scanner provides a scanner and tokenizer for UTF-8-encoded text.
tabwriter
Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text.
template
Package template implements data-driven templates for generating textual output.
template/parse
Package parse builds parse trees for templates as defined by text/template and html/template.
time
Package time provides functionality for measuring and displaying time.
tzdata
Package tzdata provides an embedded copy of the timezone database.
unicode
Package unicode provides data and functions to test some properties of Unicode code points.
utf16
Package utf16 implements encoding and decoding of UTF-16 sequences.
utf8
Package utf8 implements functions and constants to support text encoded in UTF-8.
unsafe
Package unsafe contains operations that step around the type safety of Go programs.
""",
    "separator": "// Please create a very short program which combines go standard library features in a complex way",
    "begin": "package main\nimport (",
    "target_api": "",
}

go_atomic = {
    "docstring": """
    Overview ¶
Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.

These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.

The swap operation, implemented by the SwapT functions, is the atomic equivalent of:

old = *addr
*addr = new
return old
The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of:

if *addr == old {
	*addr = new
	return true
}
return false
The add operation, implemented by the AddT functions, is the atomic equivalent of:

*addr += delta
return *addr
The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of "return *addr" and "*addr = val".

In the terminology of the Go memory model, if the effect of an atomic operation A is observed by atomic operation B, then A “synchronizes before” B. Additionally, all the atomic operations executed in a program behave as though executed in some sequentially consistent order. This definition provides the same semantics as C++'s sequentially consistent atomics and Java's volatile variables.

func AddInt32(addr *int32, delta int32) (new int32)
func AddInt64(addr *int64, delta int64) (new int64)
func AddUint32(addr *uint32, delta uint32) (new uint32)
func AddUint64(addr *uint64, delta uint64) (new uint64)
func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)
func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)
func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)
func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)
func LoadInt32(addr *int32) (val int32)
func LoadInt64(addr *int64) (val int64)
func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
func LoadUint32(addr *uint32) (val uint32)
func LoadUint64(addr *uint64) (val uint64)
func LoadUintptr(addr *uintptr) (val uintptr)
func StoreInt32(addr *int32, val int32)
func StoreInt64(addr *int64, val int64)
func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
func StoreUint32(addr *uint32, val uint32)
func StoreUint64(addr *uint64, val uint64)
func StoreUintptr(addr *uintptr, val uintptr)
func SwapInt32(addr *int32, new int32) (old int32)
func SwapInt64(addr *int64, new int64) (old int64)
func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)
func SwapUint32(addr *uint32, new uint32) (old uint32)
func SwapUint64(addr *uint64, new uint64) (old uint64)
func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)
type Bool
func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)
func (x *Bool) Load() bool
func (x *Bool) Store(val bool)
func (x *Bool) Swap(new bool) (old bool)
type Int32
func (x *Int32) Add(delta int32) (new int32)
func (x *Int32) CompareAndSwap(old, new int32) (swapped bool)
func (x *Int32) Load() int32
func (x *Int32) Store(val int32)
func (x *Int32) Swap(new int32) (old int32)
type Int64
func (x *Int64) Add(delta int64) (new int64)
func (x *Int64) CompareAndSwap(old, new int64) (swapped bool)
func (x *Int64) Load() int64
func (x *Int64) Store(val int64)
func (x *Int64) Swap(new int64) (old int64)
type Pointer
func (x *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)
func (x *Pointer[T]) Load() *T
func (x *Pointer[T]) Store(val *T)
func (x *Pointer[T]) Swap(new *T) (old *T)
type Uint32
func (x *Uint32) Add(delta uint32) (new uint32)
func (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool)
func (x *Uint32) Load() uint32
func (x *Uint32) Store(val uint32)
func (x *Uint32) Swap(new uint32) (old uint32)
type Uint64
func (x *Uint64) Add(delta uint64) (new uint64)
func (x *Uint64) CompareAndSwap(old, new uint64) (swapped bool)
func (x *Uint64) Load() uint64
func (x *Uint64) Store(val uint64)
func (x *Uint64) Swap(new uint64) (old uint64)
type Uintptr
func (x *Uintptr) Add(delta uintptr) (new uintptr)
func (x *Uintptr) CompareAndSwap(old, new uintptr) (swapped bool)
func (x *Uintptr) Load() uintptr
func (x *Uintptr) Store(val uintptr)
func (x *Uintptr) Swap(new uintptr) (old uintptr)
type Value
func (v *Value) CompareAndSwap(old, new any) (swapped bool)
func (v *Value) Load() (val any)
func (v *Value) Store(val any)
func (v *Value) Swap(new any) (old any)
    """,
    "separator": "// Please create a very short program which combines atomic with other go features in a complex way",
    "begin": 'package main\nimport (\n\t"sync/atomic"\n)\n',
    "target_api": "atomic",
}

go_bytes = {
    "docstring": """
Overview ¶
Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.

Index ¶
Constants
Variables
func Clone(b []byte) []byte
func Compare(a, b []byte) int
func Contains(b, subslice []byte) bool
func ContainsAny(b []byte, chars string) bool
func ContainsRune(b []byte, r rune) bool
func Count(s, sep []byte) int
func Cut(s, sep []byte) (before, after []byte, found bool)
func CutPrefix(s, prefix []byte) (after []byte, found bool)
func CutSuffix(s, suffix []byte) (before []byte, found bool)
func Equal(a, b []byte) bool
func EqualFold(s, t []byte) bool
func Fields(s []byte) [][]byte
func FieldsFunc(s []byte, f func(rune) bool) [][]byte
func HasPrefix(s, prefix []byte) bool
func HasSuffix(s, suffix []byte) bool
func Index(s, sep []byte) int
func IndexAny(s []byte, chars string) int
func IndexByte(b []byte, c byte) int
func IndexFunc(s []byte, f func(r rune) bool) int
func IndexRune(s []byte, r rune) int
func Join(s [][]byte, sep []byte) []byte
func LastIndex(s, sep []byte) int
func LastIndexAny(s []byte, chars string) int
func LastIndexByte(s []byte, c byte) int
func LastIndexFunc(s []byte, f func(r rune) bool) int
func Map(mapping func(r rune) rune, s []byte) []byte
func Repeat(b []byte, count int) []byte
func Replace(s, old, new []byte, n int) []byte
func ReplaceAll(s, old, new []byte) []byte
func Runes(s []byte) []rune
func Split(s, sep []byte) [][]byte
func SplitAfter(s, sep []byte) [][]byte
func SplitAfterN(s, sep []byte, n int) [][]byte
func SplitN(s, sep []byte, n int) [][]byte
func Title(s []byte) []byteDEPRECATED
func ToLower(s []byte) []byte
func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte
func ToTitle(s []byte) []byte
func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte
func ToUpper(s []byte) []byte
func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte
func ToValidUTF8(s, replacement []byte) []byte
func Trim(s []byte, cutset string) []byte
func TrimFunc(s []byte, f func(r rune) bool) []byte
func TrimLeft(s []byte, cutset string) []byte
func TrimLeftFunc(s []byte, f func(r rune) bool) []byte
func TrimPrefix(s, prefix []byte) []byte
func TrimRight(s []byte, cutset string) []byte
func TrimRightFunc(s []byte, f func(r rune) bool) []byte
func TrimSpace(s []byte) []byte
func TrimSuffix(s, suffix []byte) []byte
type Buffer
func NewBuffer(buf []byte) *Buffer
func NewBufferString(s string) *Buffer
func (b *Buffer) Bytes() []byte
func (b *Buffer) Cap() int
func (b *Buffer) Grow(n int)
func (b *Buffer) Len() int
func (b *Buffer) Next(n int) []byte
func (b *Buffer) Read(p []byte) (n int, err error)
func (b *Buffer) ReadByte() (byte, error)
func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)
func (b *Buffer) ReadRune() (r rune, size int, err error)
func (b *Buffer) ReadString(delim byte) (line string, err error)
func (b *Buffer) Reset()
func (b *Buffer) String() string
func (b *Buffer) Truncate(n int)
func (b *Buffer) UnreadByte() error
func (b *Buffer) UnreadRune() error
func (b *Buffer) Write(p []byte) (n int, err error)
func (b *Buffer) WriteByte(c byte) error
func (b *Buffer) WriteRune(r rune) (n int, err error)
func (b *Buffer) WriteString(s string) (n int, err error)
func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)
type Reader
func NewReader(b []byte) *Reader
func (r *Reader) Len() int
func (r *Reader) Read(b []byte) (n int, err error)
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
func (r *Reader) ReadByte() (byte, error)
func (r *Reader) ReadRune() (ch rune, size int, err error)
func (r *Reader) Reset(b []byte)
func (r *Reader) Seek(offset int64, whence int) (int64, error)
func (r *Reader) Size() int64
func (r *Reader) UnreadByte() error
func (r *Reader) UnreadRune() error
func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
Examples ¶
Buffer
Buffer (Reader)
Buffer.Bytes
Buffer.Cap
Buffer.Grow
Buffer.Len
Buffer.Next
Buffer.Read
Buffer.ReadByte
Compare
Compare (Search)
Contains
ContainsAny
ContainsRune
Count
Cut
Equal
EqualFold
Fields
FieldsFunc
HasPrefix
HasSuffix
Index
IndexAny
IndexByte
IndexFunc
IndexRune
Join
LastIndex
LastIndexAny
LastIndexByte
LastIndexFunc
Reader.Len
Repeat
Replace
ReplaceAll
Runes
Split
SplitAfter
SplitAfterN
SplitN
Title
ToLower
ToLowerSpecial
ToTitle
ToTitleSpecial
ToUpper
ToUpperSpecial
Trim
TrimFunc
TrimLeft
TrimLeftFunc
TrimPrefix
TrimRight
TrimRightFunc
TrimSpace
TrimSuffix
""",
    "separator": "// Please create a very short program which combines bytes with other go features in a complex way",
    "begin": 'package main\nimport (\n\t"bytes"\n',
    "target_api": "bytes",
}

go_maphash = {
    "docstring": """
Overview ¶
Package maphash provides hash functions on byte sequences. These hash functions are intended to be used to implement hash tables or other data structures that need to map arbitrary strings or byte sequences to a uniform distribution on unsigned 64-bit integers. Each different instance of a hash table or data structure should use its own Seed.

The hash functions are not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)

Example ¶
Index ¶
func Bytes(seed Seed, b []byte) uint64
func String(seed Seed, s string) uint64
type Hash
func (h *Hash) BlockSize() int
func (h *Hash) Reset()
func (h *Hash) Seed() Seed
func (h *Hash) SetSeed(seed Seed)
func (h *Hash) Size() int
func (h *Hash) Sum(b []byte) []byte
func (h *Hash) Sum64() uint64
func (h *Hash) Write(b []byte) (int, error)
func (h *Hash) WriteByte(b byte) error
func (h *Hash) WriteString(s string) (int, error)
type Seed
func MakeSeed() Seed
Examples ¶
Package
Constants ¶
This section is empty.

Variables ¶
This section is empty.

Functions ¶
func Bytes ¶
added in go1.19
func Bytes(seed Seed, b []byte) uint64
Bytes returns the hash of b with the given seed.

Bytes is equivalent to, but more convenient and efficient than:

var h Hash
h.SetSeed(seed)
h.Write(b)
return h.Sum64()
func String ¶
added in go1.19
func String(seed Seed, s string) uint64
String returns the hash of s with the given seed.

String is equivalent to, but more convenient and efficient than:

var h Hash
h.SetSeed(seed)
h.WriteString(s)
return h.Sum64()
Types ¶
type Hash ¶
type Hash struct {
	// contains filtered or unexported fields
}
A Hash computes a seeded hash of a byte sequence.

The zero Hash is a valid Hash ready to use. A zero Hash chooses a random seed for itself during the first call to a Reset, Write, Seed, or Sum64 method. For control over the seed, use SetSeed.

The computed hash values depend only on the initial seed and the sequence of bytes provided to the Hash object, not on the way in which the bytes are provided. For example, the three sequences

h.Write([]byte{'f','o','o'})
h.WriteByte('f'); h.WriteByte('o'); h.WriteByte('o')
h.WriteString("foo")
all have the same effect.

Hashes are intended to be collision-resistant, even for situations where an adversary controls the byte sequences being hashed.

A Hash is not safe for concurrent use by multiple goroutines, but a Seed is. If multiple goroutines must compute the same seeded hash, each can declare its own Hash and call SetSeed with a common Seed.

func (*Hash) BlockSize ¶
func (h *Hash) BlockSize() int
BlockSize returns h's block size.

func (*Hash) Reset ¶
func (h *Hash) Reset()
Reset discards all bytes added to h. (The seed remains the same.)

func (*Hash) Seed ¶
func (h *Hash) Seed() Seed
Seed returns h's seed value.

func (*Hash) SetSeed ¶
func (h *Hash) SetSeed(seed Seed)
SetSeed sets h to use seed, which must have been returned by MakeSeed or by another Hash's Seed method. Two Hash objects with the same seed behave identically. Two Hash objects with different seeds will very likely behave differently. Any bytes added to h before this call will be discarded.

func (*Hash) Size ¶
func (h *Hash) Size() int
Size returns h's hash value size, 8 bytes.

func (*Hash) Sum ¶
func (h *Hash) Sum(b []byte) []byte
Sum appends the hash's current 64-bit value to b. It exists for implementing hash.Hash. For direct calls, it is more efficient to use Sum64.

func (*Hash) Sum64 ¶
func (h *Hash) Sum64() uint64
Sum64 returns h's current 64-bit value, which depends on h's seed and the sequence of bytes added to h since the last call to Reset or SetSeed.

All bits of the Sum64 result are close to uniformly and independently distributed, so it can be safely reduced by using bit masking, shifting, or modular arithmetic.

func (*Hash) Write ¶
func (h *Hash) Write(b []byte) (int, error)
Write adds b to the sequence of bytes hashed by h. It always writes all of b and never fails; the count and error result are for implementing io.Writer.

func (*Hash) WriteByte ¶
func (h *Hash) WriteByte(b byte) error
WriteByte adds b to the sequence of bytes hashed by h. It never fails; the error result is for implementing io.ByteWriter.

func (*Hash) WriteString ¶
func (h *Hash) WriteString(s string) (int, error)
WriteString adds the bytes of s to the sequence of bytes hashed by h. It always writes all of s and never fails; the count and error result are for implementing io.StringWriter.

type Seed ¶
type Seed struct {
	// contains filtered or unexported fields
}
A Seed is a random value that selects the specific hash function computed by a Hash. If two Hashes use the same Seeds, they will compute the same hash values for any given input. If two Hashes use different Seeds, they are very likely to compute distinct hash values for any given input.

A Seed must be initialized by calling MakeSeed. The zero seed is uninitialized and not valid for use with Hash's SetSeed method.

Each Seed value is local to a single process and cannot be serialized or otherwise recreated in a different process.

func MakeSeed ¶
func MakeSeed() Seed
MakeSeed returns a new random seed.
""",
    "separator": "// Please create a very short program which combines maphash with other go features in a complex way",
    "begin": 'package main\nimport (\n\t"hash/maphash"\n',
    "target_api": "maphash",
}

go_strconv = {
    "docstring": """
Overview ¶
Numeric Conversions
String Conversions
Package strconv implements conversions to and from string representations of basic data types.

Numeric Conversions ¶
The most common numeric conversions are Atoi (string to int) and Itoa (int to string).

i, err := strconv.Atoi("-42")
s := strconv.Itoa(-42)
These assume decimal and the Go int type.

ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:

b, err := strconv.ParseBool("true")
f, err := strconv.ParseFloat("3.1415", 64)
i, err := strconv.ParseInt("-42", 10, 64)
u, err := strconv.ParseUint("42", 10, 64)
The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:

s := "2147483647" // biggest int32
i64, err := strconv.ParseInt(s, 10, 32)
...
i := int32(i64)
FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:

s := strconv.FormatBool(true)
s := strconv.FormatFloat(3.1415, 'E', -1, 64)
s := strconv.FormatInt(-42, 16)
s := strconv.FormatUint(42, 16)
AppendBool, AppendFloat, AppendInt, and AppendUint are similar but append the formatted value to a destination slice.

String Conversions ¶
Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with:

q := strconv.Quote("Hello, 世界")
q := strconv.QuoteToASCII("Hello, 世界")
QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals.

Unquote and UnquoteChar unquote Go string and rune literals.

Index ¶
Constants
Variables
func AppendBool(dst []byte, b bool) []byte
func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte
func AppendInt(dst []byte, i int64, base int) []byte
func AppendQuote(dst []byte, s string) []byte
func AppendQuoteRune(dst []byte, r rune) []byte
func AppendQuoteRuneToASCII(dst []byte, r rune) []byte
func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte
func AppendQuoteToASCII(dst []byte, s string) []byte
func AppendQuoteToGraphic(dst []byte, s string) []byte
func AppendUint(dst []byte, i uint64, base int) []byte
func Atoi(s string) (int, error)
func CanBackquote(s string) bool
func FormatBool(b bool) string
func FormatComplex(c complex128, fmt byte, prec, bitSize int) string
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
func FormatInt(i int64, base int) string
func FormatUint(i uint64, base int) string
func IsGraphic(r rune) bool
func IsPrint(r rune) bool
func Itoa(i int) string
func ParseBool(str string) (bool, error)
func ParseComplex(s string, bitSize int) (complex128, error)
func ParseFloat(s string, bitSize int) (float64, error)
func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseUint(s string, base int, bitSize int) (uint64, error)
func Quote(s string) string
func QuoteRune(r rune) string
func QuoteRuneToASCII(r rune) string
func QuoteRuneToGraphic(r rune) string
func QuoteToASCII(s string) string
func QuoteToGraphic(s string) string
func QuotedPrefix(s string) (string, error)
func Unquote(s string) (string, error)
func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)
type NumError
""",
    "separator": "// Please create a very short program which combines strconv with other go features in a complex way",
    "begin": 'package main\nimport (\n\t"strconv"\n',
    "target_api": "strconv",
}

go_reflect = {
    "docstring": """
    Overview ¶
Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.

A call to ValueOf returns a Value representing the run-time data. Zero takes a Type and returns a Value representing a zero value for that type.

See "The Laws of Reflection" for an introduction to reflection in Go: https://golang.org/doc/articles/laws_of_reflection.html

Index ¶
Constants
func Copy(dst, src Value) int
func DeepEqual(x, y any) bool
func Swapper(slice any) func(i, j int)
type ChanDir
func (d ChanDir) String() string
type Kind
func (k Kind) String() string
type MapIter
func (iter *MapIter) Key() Value
func (iter *MapIter) Next() bool
func (iter *MapIter) Reset(v Value)
func (iter *MapIter) Value() Value
type Method
func (m Method) IsExported() bool
type SelectCase
type SelectDir
type SliceHeader
type StringHeader
type StructField
func VisibleFields(t Type) []StructField
func (f StructField) IsExported() bool
type StructTag
func (tag StructTag) Get(key string) string
func (tag StructTag) Lookup(key string) (value string, ok bool)
type Type
func ArrayOf(length int, elem Type) Type
func ChanOf(dir ChanDir, t Type) Type
func FuncOf(in, out []Type, variadic bool) Type
func MapOf(key, elem Type) Type
func PointerTo(t Type) Type
func PtrTo(t Type) Type
func SliceOf(t Type) Type
func StructOf(fields []StructField) Type
func TypeOf(i any) Type
type Value
func Append(s Value, x ...Value) Value
func AppendSlice(s, t Value) Value
func Indirect(v Value) Value
func MakeChan(typ Type, buffer int) Value
func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value
func MakeMap(typ Type) Value
func MakeMapWithSize(typ Type, n int) Value
func MakeSlice(typ Type, len, cap int) Value
func New(typ Type) Value
func NewAt(typ Type, p unsafe.Pointer) Value
func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)
func ValueOf(i any) Value
func Zero(typ Type) Value
func (v Value) Addr() Value
func (v Value) Bool() bool
func (v Value) Bytes() []byte
func (v Value) Call(in []Value) []Value
func (v Value) CallSlice(in []Value) []Value
func (v Value) CanAddr() bool
func (v Value) CanComplex() bool
func (v Value) CanConvert(t Type) bool
func (v Value) CanFloat() bool
func (v Value) CanInt() bool
func (v Value) CanInterface() bool
func (v Value) CanSet() bool
func (v Value) CanUint() bool
func (v Value) Cap() int
func (v Value) Close()
func (v Value) Comparable() bool
func (v Value) Complex() complex128
func (v Value) Convert(t Type) Value
func (v Value) Elem() Value
func (v Value) Equal(u Value) bool
func (v Value) Field(i int) Value
func (v Value) FieldByIndex(index []int) Value
func (v Value) FieldByIndexErr(index []int) (Value, error)
func (v Value) FieldByName(name string) Value
func (v Value) FieldByNameFunc(match func(string) bool) Value
func (v Value) Float() float64
func (v Value) Grow(n int)
func (v Value) Index(i int) Value
func (v Value) Int() int64
func (v Value) Interface() (i any)
func (v Value) InterfaceData() [2]uintptrDEPRECATED
func (v Value) IsNil() bool
func (v Value) IsValid() bool
func (v Value) IsZero() bool
func (v Value) Kind() Kind
func (v Value) Len() int
func (v Value) MapIndex(key Value) Value
func (v Value) MapKeys() []Value
func (v Value) MapRange() *MapIter
func (v Value) Method(i int) Value
func (v Value) MethodByName(name string) Value
func (v Value) NumField() int
func (v Value) NumMethod() int
func (v Value) OverflowComplex(x complex128) bool
func (v Value) OverflowFloat(x float64) bool
func (v Value) OverflowInt(x int64) bool
func (v Value) OverflowUint(x uint64) bool
func (v Value) Pointer() uintptr
func (v Value) Recv() (x Value, ok bool)
func (v Value) Send(x Value)
func (v Value) Set(x Value)
func (v Value) SetBool(x bool)
func (v Value) SetBytes(x []byte)
func (v Value) SetCap(n int)
func (v Value) SetComplex(x complex128)
func (v Value) SetFloat(x float64)
func (v Value) SetInt(x int64)
func (v Value) SetIterKey(iter *MapIter)
func (v Value) SetIterValue(iter *MapIter)
func (v Value) SetLen(n int)
func (v Value) SetMapIndex(key, elem Value)
func (v Value) SetPointer(x unsafe.Pointer)
func (v Value) SetString(x string)
func (v Value) SetUint(x uint64)
func (v Value) SetZero()
func (v Value) Slice(i, j int) Value
func (v Value) Slice3(i, j, k int) Value
func (v Value) String() string
func (v Value) TryRecv() (x Value, ok bool)
func (v Value) TrySend(x Value) bool
func (v Value) Type() Type
func (v Value) Uint() uint64
func (v Value) UnsafeAddr() uintptr
func (v Value) UnsafePointer() unsafe.Pointer
type ValueError
func (e *ValueError) Error() string
""",
    "separator": "// Please create a very short program which combines reflect with other go features in a complex way",
    "begin": 'package main\nimport (\n\t"reflect"\n',
    "target_api": "reflect",
}
go_big_math = {
    "docstring": """
Overview ¶
Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported:

Int    signed integers
Rat    rational numbers
Float  floating-point numbers
The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:

var x Int        // &x is an *Int of value 0
var r = &Rat{}   // r is a *Rat of value 0
y := new(Float)  // y is a *Float of value 0
Alternatively, new values can be allocated and initialized with factory functions of the form:

func NewT(v V) *T
For instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:

var z1 Int
z1.SetUint64(123)                 // z1 := 123
z2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4
z3 := new(Float).SetInt(z1)       // z3 := 123.0
Setters, numeric operations and predicates are represented as methods of the form:

func (z *T) SetV(v V) *T          // z = v
func (z *T) Unary(x *T) *T        // z = unary x
func (z *T) Binary(x, y *T) *T    // z = x binary y
func (x *T) Pred() P              // p = pred(x)
with T one of Int, Rat, or Float. For unary and binary operations, the result is the receiver (usually named z in that case; see below); if it is one of the operands x or y it may be safely overwritten (and its memory reused).

Arithmetic expressions are typically written as a sequence of individual method calls, with each call corresponding to an operation. The receiver denotes the result and the method arguments are the operation's operands. For instance, given three *Int values a, b and c, the invocation

c.Add(a, b)
computes the sum a + b and stores the result in c, overwriting whatever value was held in c before. Unless specified otherwise, operations permit aliasing of parameters, so it is perfectly ok to write

sum.Add(sum, x)
to accumulate values x in a sum.

(By always passing in a result value via the receiver, memory use can be much better controlled. Instead of having to allocate new memory for each result, an operation can reuse the space allocated for the result value, and overwrite that value with the new result in the process.)

Notational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver).

For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:

func (z *Int) Add(x, y *Int) *Int
Methods of this form typically return the incoming receiver as well, to enable simple call chaining.

Methods which don't require a result value to be passed in (for instance, Int.Sign), simply return the result. In this case, the receiver is typically the first operand, named x:

func (x *Int) Sign() int
Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).

Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface for scanning and (except for *Rat) the Formatter interface for formatted printing.

Example (EConvergents) ¶
Example (Fibonacci) ¶
Example (Sqrt2) ¶
Index ¶
Constants
func Jacobi(x, y *Int) int
type Accuracy
func (i Accuracy) String() string
type ErrNaN
func (err ErrNaN) Error() string
type Float
func NewFloat(x float64) *Float
func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)
func (z *Float) Abs(x *Float) *Float
func (x *Float) Acc() Accuracy
func (z *Float) Add(x, y *Float) *Float
func (x *Float) Append(buf []byte, fmt byte, prec int) []byte
func (x *Float) Cmp(y *Float) int
func (z *Float) Copy(x *Float) *Float
func (x *Float) Float32() (float32, Accuracy)
func (x *Float) Float64() (float64, Accuracy)
func (x *Float) Format(s fmt.State, format rune)
func (z *Float) GobDecode(buf []byte) error
func (x *Float) GobEncode() ([]byte, error)
func (x *Float) Int(z *Int) (*Int, Accuracy)
func (x *Float) Int64() (int64, Accuracy)
func (x *Float) IsInf() bool
func (x *Float) IsInt() bool
func (x *Float) MantExp(mant *Float) (exp int)
func (x *Float) MarshalText() (text []byte, err error)
func (x *Float) MinPrec() uint
func (x *Float) Mode() RoundingMode
func (z *Float) Mul(x, y *Float) *Float
func (z *Float) Neg(x *Float) *Float
func (z *Float) Parse(s string, base int) (f *Float, b int, err error)
func (x *Float) Prec() uint
func (z *Float) Quo(x, y *Float) *Float
func (x *Float) Rat(z *Rat) (*Rat, Accuracy)
func (z *Float) Scan(s fmt.ScanState, ch rune) error
func (z *Float) Set(x *Float) *Float
func (z *Float) SetFloat64(x float64) *Float
func (z *Float) SetInf(signbit bool) *Float
func (z *Float) SetInt(x *Int) *Float
func (z *Float) SetInt64(x int64) *Float
func (z *Float) SetMantExp(mant *Float, exp int) *Float
func (z *Float) SetMode(mode RoundingMode) *Float
func (z *Float) SetPrec(prec uint) *Float
func (z *Float) SetRat(x *Rat) *Float
func (z *Float) SetString(s string) (*Float, bool)
func (z *Float) SetUint64(x uint64) *Float
func (x *Float) Sign() int
func (x *Float) Signbit() bool
func (z *Float) Sqrt(x *Float) *Float
func (x *Float) String() string
func (z *Float) Sub(x, y *Float) *Float
func (x *Float) Text(format byte, prec int) string
func (x *Float) Uint64() (uint64, Accuracy)
func (z *Float) UnmarshalText(text []byte) error
type Int
func NewInt(x int64) *Int
func (z *Int) Abs(x *Int) *Int
func (z *Int) Add(x, y *Int) *Int
func (z *Int) And(x, y *Int) *Int
func (z *Int) AndNot(x, y *Int) *Int
func (x *Int) Append(buf []byte, base int) []byte
func (z *Int) Binomial(n, k int64) *Int
func (x *Int) Bit(i int) uint
func (x *Int) BitLen() int
func (x *Int) Bits() []Word
func (x *Int) Bytes() []byte
func (x *Int) Cmp(y *Int) (r int)
func (x *Int) CmpAbs(y *Int) int
func (z *Int) Div(x, y *Int) *Int
func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)
func (z *Int) Exp(x, y, m *Int) *Int
func (x *Int) FillBytes(buf []byte) []byte
func (x *Int) Format(s fmt.State, ch rune)
func (z *Int) GCD(x, y, a, b *Int) *Int
func (z *Int) GobDecode(buf []byte) error
func (x *Int) GobEncode() ([]byte, error)
func (x *Int) Int64() int64
func (x *Int) IsInt64() bool
func (x *Int) IsUint64() bool
func (z *Int) Lsh(x *Int, n uint) *Int
func (x *Int) MarshalJSON() ([]byte, error)
func (x *Int) MarshalText() (text []byte, err error)
func (z *Int) Mod(x, y *Int) *Int
func (z *Int) ModInverse(g, n *Int) *Int
func (z *Int) ModSqrt(x, p *Int) *Int
func (z *Int) Mul(x, y *Int) *Int
func (z *Int) MulRange(a, b int64) *Int
func (z *Int) Neg(x *Int) *Int
func (z *Int) Not(x *Int) *Int
func (z *Int) Or(x, y *Int) *Int
func (x *Int) ProbablyPrime(n int) bool
func (z *Int) Quo(x, y *Int) *Int
func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)
func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int
func (z *Int) Rem(x, y *Int) *Int
func (z *Int) Rsh(x *Int, n uint) *Int
func (z *Int) Scan(s fmt.ScanState, ch rune) error
func (z *Int) Set(x *Int) *Int
func (z *Int) SetBit(x *Int, i int, b uint) *Int
func (z *Int) SetBits(abs []Word) *Int
func (z *Int) SetBytes(buf []byte) *Int
func (z *Int) SetInt64(x int64) *Int
func (z *Int) SetString(s string, base int) (*Int, bool)
func (z *Int) SetUint64(x uint64) *Int
func (x *Int) Sign() int
func (z *Int) Sqrt(x *Int) *Int
func (x *Int) String() string
func (z *Int) Sub(x, y *Int) *Int
func (x *Int) Text(base int) string
func (x *Int) TrailingZeroBits() uint
func (x *Int) Uint64() uint64
func (z *Int) UnmarshalJSON(text []byte) error
func (z *Int) UnmarshalText(text []byte) error
func (z *Int) Xor(x, y *Int) *Int
type Rat
func NewRat(a, b int64) *Rat
func (z *Rat) Abs(x *Rat) *Rat
func (z *Rat) Add(x, y *Rat) *Rat
func (x *Rat) Cmp(y *Rat) int
func (x *Rat) Denom() *Int
func (x *Rat) Float32() (f float32, exact bool)
func (x *Rat) Float64() (f float64, exact bool)
func (x *Rat) FloatString(prec int) string
func (z *Rat) GobDecode(buf []byte) error
func (x *Rat) GobEncode() ([]byte, error)
func (z *Rat) Inv(x *Rat) *Rat
func (x *Rat) IsInt() bool
func (x *Rat) MarshalText() (text []byte, err error)
func (z *Rat) Mul(x, y *Rat) *Rat
func (z *Rat) Neg(x *Rat) *Rat
func (x *Rat) Num() *Int
func (z *Rat) Quo(x, y *Rat) *Rat
func (x *Rat) RatString() string
func (z *Rat) Scan(s fmt.ScanState, ch rune) error
func (z *Rat) Set(x *Rat) *Rat
func (z *Rat) SetFloat64(f float64) *Rat
func (z *Rat) SetFrac(a, b *Int) *Rat
func (z *Rat) SetFrac64(a, b int64) *Rat
func (z *Rat) SetInt(x *Int) *Rat
func (z *Rat) SetInt64(x int64) *Rat
func (z *Rat) SetString(s string) (*Rat, bool)
func (z *Rat) SetUint64(x uint64) *Rat
func (x *Rat) Sign() int
func (x *Rat) String() string
func (z *Rat) Sub(x, y *Rat) *Rat
func (z *Rat) UnmarshalText(text []byte) error
type RoundingMode
func (i RoundingMode) String() string
type Word
""",
    "separator": "// Please create a very short program which combines big math with other go features in a complex way",
    "begin": 'package main\nimport (\n\t"math/big"\n)\n',
    "target_api": "big",
}

go_heap = {
    "docstring": """
Overview ¶
Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.

The minimum element in the tree is the root, at index 0.

A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.

Index ¶
func Fix(h Interface, i int)
func Init(h Interface)
func Pop(h Interface) any
func Push(h Interface, x any)
func Remove(h Interface, i int) any
type Interface
Examples ¶
Package (IntHeap)
Package (PriorityQueue)
Constants ¶
This section is empty.

Variables ¶
This section is empty.

Functions ¶
func Fix ¶
added in go1.2
func Fix(h Interface, i int)
Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value. The complexity is O(log n) where n = h.Len().

func Init ¶
func Init(h Interface)
Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len().

func Pop ¶
func Pop(h Interface) any
Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to Remove(h, 0).

func Push ¶
func Push(h Interface, x any)
Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len().

func Remove ¶
func Remove(h Interface, i int) any
Remove removes and returns the element at index i from the heap. The complexity is O(log n) where n = h.Len().

Types ¶
type Interface ¶
type Interface interface {
	sort.Interface
	Push(x any) // add x as element Len()
	Pop() any   // remove and return element Len() - 1.
}
The Interface type describes the requirements for a type using the routines in this package. Any type that implements it may be used as a min-heap with the following invariants (established after Init has been called or if the data is empty or sorted):

!h.Less(j, i) for 0 <= i < h.Len() and 2*i+1 <= j <= 2*i+2 and j < h.Len()
Note that Push and Pop in this interface are for package heap's implementation to call. To add and remove things from the heap, use heap.Push and heap.Pop.
""",
    "separator": "// Please create a very short program which combines heap with other go features in a complex way",
    "begin": 'package main\nimport (\n\t"container/heap"\n)\n',
    "target_api": "heap",
}
